<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="UTF-8">
  <title>Heart Particle 3D</title>
  <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/FontLoader.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/geometries/TextGeometry.js"></script>

  <style>
    body {
      margin: 0;
      overflow: hidden;
      background-color: black;
    }
    canvas {
      display: block;
    }
  </style>
</head>
<body>
  <script>
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);
  
    const controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;
  
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
    scene.add(ambientLight);
  
    const pointLight = new THREE.PointLight(0xff0077, 1, 100);
    pointLight.position.set(20, 20, 20);
    scene.add(pointLight);
  
    function heartFunction(t) {
      const x = 16 * Math.pow(Math.sin(t), 3);
      const y = 13 * Math.cos(t) - 5 * Math.cos(2 * t) - 2 * Math.cos(3 * t) - Math.cos(4 * t);
      return { x, y };
    }
  
    const particleCount = 2000;
    const geometry = new THREE.BufferGeometry();
    const positions = new Float32Array(particleCount * 3);
    const colors = new Float32Array(particleCount * 3);
    const tArray = new Float32Array(particleCount);
  
    for (let i = 0; i < particleCount; i++) {
      const t = Math.random() * Math.PI * 2;
      const { x, y } = heartFunction(t);
      const z = (Math.random() - 0.5) * 10;
  
      positions[i * 3] = x;
      positions[i * 3 + 1] = y;
      positions[i * 3 + 2] = z;
  
      colors[i * 3] = 1.0;
      colors[i * 3 + 1] = 0.2;
      colors[i * 3 + 2] = 0.5;
  
      tArray[i] = t;
    }
  
    geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
  
    const material = new THREE.PointsMaterial({
      size: 0.01,
      vertexColors: true,
      transparent: true,
      opacity: 0.9
    });
  
    const points = new THREE.Points(geometry, material);
    scene.add(points);
  
    camera.position.z = 50;
    camera.position.y = 20;
  
    let textPositions = [];
  
    // Chuyển chữ thành điểm particles bằng canvas
    function generateTextPositions(text) {
      const canvas = document.createElement('canvas');
      canvas.width = 300;
      canvas.height = 100;
      const ctx = canvas.getContext('2d');
      ctx.fillStyle = 'white';
      ctx.font = 'bold 32px sans-serif';
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText(text, canvas.width / 2, canvas.height / 2);
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height).data;
  
      const tempPositions = [];
  
      for (let y = 0; y < canvas.height; y += 2) {
        for (let x = 0; x < canvas.width; x += 2) {
          const index = (y * canvas.width + x) * 4;
          const alpha = imageData[index + 3];
          if (alpha > 128) {
            // Scale xuống và căn giữa
            tempPositions.push({
              x: (x - canvas.width / 2) / 10,
              y: -(y - canvas.height / 2) / 10,
              z: 0
            });
          }
        }
      }
  
      return tempPositions;
    }
  
    // Gán dữ liệu chữ vào textPositions
    textPositions = generateTextPositions("Anh Yêu Em");
  
    // Animate
    function animate() {
      requestAnimationFrame(animate);
  
      const pos = geometry.attributes.position.array;
      for (let i = 0; i < particleCount; i++) {
        tArray[i] += 0.002;
  
        const { x, y } = heartFunction(tArray[i]);
        const zOffset = Math.sin(tArray[i] * 3 + i) * 2;
        const cosValue = Math.cos(tArray[i] * 3 + i);
        const z = zOffset / (5 * Math.abs(cosValue) + 0.2) * 2;
  
        if (textPositions.length > 0 && i < textPositions.length) {
          pos[i * 3] += (textPositions[i].x - pos[i * 3]) * 0.05;
          pos[i * 3 + 1] += (textPositions[i].y - pos[i * 3 + 1]) * 0.05;
          const waveZ = Math.sin(textPositions[i].x + performance.now() * 0.002) * 
          Math.cos(textPositions[i].y + performance.now() * 0.001) * 1.1;

          pos[i * 3 + 2] += (waveZ - pos[i * 3 + 2]) * 0.05;
    } else {
          pos[i * 3] = x;
          pos[i * 3 + 1] = y;
          pos[i * 3 + 2] = z;
        }
      }
  
      geometry.attributes.position.needsUpdate = true;
      points.rotation.y += 0.001;
      controls.update();
      renderer.render(scene, camera);
    }
  
    animate();
  
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
  
</body>
</html>